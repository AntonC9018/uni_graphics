<!DOCTYPE html>
<html>
<head>
<title>Grafica_Laborator_1.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/*
Monokai style - ported by Luigi Maselli - http://grigio.org
*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #272822;
  color: #ddd;
}

.hljs-tag,
.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-strong,
.hljs-name {
  color: #f92672;
}

.hljs-code {
  color: #66d9ef;
}

.hljs-class .hljs-title {
  color: white;
}

.hljs-attribute,
.hljs-symbol,
.hljs-regexp,
.hljs-link {
  color: #bf79db;
}

.hljs-string,
.hljs-bullet,
.hljs-subst,
.hljs-title,
.hljs-section,
.hljs-emphasis,
.hljs-type,
.hljs-built_in,
.hljs-builtin-name,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-addition,
.hljs-variable,
.hljs-template-tag,
.hljs-template-variable {
  color: #a6e22e;
}

.hljs-comment,
.hljs-quote,
.hljs-deletion,
.hljs-meta {
  color: #75715e;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-doctag,
.hljs-title,
.hljs-section,
.hljs-type,
.hljs-selector-id {
  font-weight: bold;
}

</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #3A07AA; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
  
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });</script>
<h1 id="lucrarea-de-laborator-nr1-la-grafica-2d-pe-calculator">Lucrarea de laborator Nr.1 la Grafica 2D pe calculator</h1>
<p>A elaborat: <strong>Curmanschii Anton, IA1901</strong>.</p>
<p>Vedeți <a href="https://github.com/AntonC9018/uni_graphics">Github</a></p>
<h2 id="sarcina">Sarcina</h2>
<ol>
<li>Este dată funcția $ f(x) = arctanh(x) $. De aproximat $ f(x) $ numeric cu precizia dată $ \epsilon $.</li>
<li>Să se creze un program ce desenează graficul funcției $ f(x) $ utilizând aproximarea numerică.</li>
<li>Să se deseneze $ f(x) $ utilizând funcția definită în librărie.</li>
<li>Să se scrie diferența dintre $ f(x) $ aproximată și cea din librărie într-un fișier, pentru fiecare x.</li>
<li>Să se scrie valorile funcției $ f(x) $ și x pentru fiecare x într-un fișier.</li>
<li>Să se verifice graficile cu un program extern.</li>
</ol>
<h2 id="realizarea">Realizarea</h2>
<h3 id="introducere">Introducere</h3>
<p>Am scris codul în limbajul de programare D care este foarte asemănător cu C, însă unele lucruri sunt mai utile și comode.</p>
<p>Așa că nu-mi trebuie multă funcționalitate pentru a desena graficuri (o fereastă grafică, linii pentru axele, text pentru valorile lui x și y), am decis să folosesc o librărie care tot este foarte simplă, <a href="https://dpldocs.info/experimental-docs/arsd.simpledisplay.html">arsd.simpledisplay</a>.</p>
<h3 id="1-aproximarea">1. Aproximarea</h3>
<p>Avem seria Maclaurin pentru $ arctanh(x) $ deja dată:</p>
<p>$$ arctanh(x) = \sum_{k = 1}^{\infty}{ \frac{ x^{2k - 1} }{ 2k - 1 }} = x + \frac{x^3}{3} + \frac{x^5}{5} + \ldots$$</p>
<p>Vom calcula funcția sumând fiecare termen aparte.
Notez, că $ x^2 $ este înmulțit cu $ x^{n_{precedent}} $, de aceea, ca să nu calculăm $ x^{n_{nou}} $ din nou de fiecare dată, putem doar să calculăm $ x^{n_{nou}} = x^2 * x^{n_{precedent}} $.
În codul de mai jos, eu pastrez acest termen nou în însăși variabila <code>x</code>.</p>
<p>Similar putem face cu numitorul, la care se adună 2 de fiecare dată.</p>
<p>Am scris un comentariu despre precizie și $ \epsilon $.
În cuvintele simple, pentru a verifica dacă aproximarea este destul de bună, nu este de ajuns de verificat dacă următorul termen este mai mic ca $ \epsilon $.
Pentru rezultatele bune aici am trebui să fac mai multă analiză referitor la modul cum eroarea depinde de următorul termen, dar îmi pare că aceasta nu este scopul lucrării.</p>
<p>Cum veți vedea pe urmă, aproximările nu sunt foarte bune pentru valori aproape de punctele terminale (-1, 1), din cauza că nu verific precizia strict matematic.</p>
<pre class="hljs"><code><div><span class="hljs-built_in">float</span> arctanh(<span class="hljs-built_in">float</span> x, <span class="hljs-built_in">float</span> epsilon)
{
	<span class="hljs-comment">// It blows up to infinity at the endpoints.</span>
	<span class="hljs-comment">// I think it's not symmetric? </span>
	<span class="hljs-comment">// I could do `x %= 1.0f` instead if it was though.</span>
	<span class="hljs-keyword">if</span> (x &lt; -<span class="hljs-number">1</span> || x &gt; <span class="hljs-number">1</span>) 
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

	<span class="hljs-built_in">float</span> x_squared = x * x;
	<span class="hljs-built_in">float</span> denumitor = <span class="hljs-number">1</span>;
	<span class="hljs-built_in">float</span> dx = x;
	<span class="hljs-built_in">float</span> y = <span class="hljs-number">0</span>;

	<span class="hljs-comment">// We bail out when the dx becomes too small to change the value significantly.</span>
	<span class="hljs-comment">// Now, the thing it, this Maclaurin series converges pretty slowly, so this is wrong.</span>
	<span class="hljs-comment">// Getting into more advanced equations does not seems like the point of the assignment,</span>
	<span class="hljs-comment">// so I shall stop here.</span>
	<span class="hljs-keyword">while</span> (abs(dx) &gt; epsilon)
	{
		y += dx;

		<span class="hljs-comment">// x^(2k - 1) / (2k - 1)</span>
		x *= x_squared;
		denumitor += <span class="hljs-number">2</span>;
		dx = x / denumitor;
	}
	<span class="hljs-keyword">return</span> y;
}
</div></code></pre>
<h3 id="2-graficul">2. Graficul</h3>
<p>Voi evidenția numai cele mai importante momente.</p>
<p>Pentru a trasa graficul funcției, trebuie să calculăm valorile funcției în punctele consecutive, între punctele terminale.
Vom uni aceste puncte consecutive cu linii, câte două.
Punctele terminale pentru funcția noastră sunt $ (-1, 1) $.</p>
<p>Deci, primul lucru este colectarea acestor puncte.</p>
<p>Pentru a reprezenta un vector (punct) floating point, am făcut o structură ajutătoare.
Datorită sintaxei simple de operator overloading în D, cu 30 linii de code deja suportez toate operațiile aritmetice între doi vectori și între un vector și un număr.</p>
<p>Am făcut și o metoda care convertează vectorul într-un <code>Point</code>, <code>Point</code> fiind structura definită de librărie, care conține tot conține 2 coordonați, însă acelea sunt numeri întregi.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">struct</span> v2
{
	<span class="hljs-built_in">float</span>[<span class="hljs-number">2</span>] arrayof;

	<span class="hljs-built_in">float</span> x() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> arrayof[<span class="hljs-number">0</span>]; }
	<span class="hljs-built_in">float</span> y() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> arrayof[<span class="hljs-number">1</span>]; }

	<span class="hljs-keyword">this</span>(<span class="hljs-built_in">float</span> x, <span class="hljs-built_in">float</span> y)
	{
		arrayof[<span class="hljs-number">0</span>] = x; 
		arrayof[<span class="hljs-number">1</span>] = y;
	}

	Point point() <span class="hljs-keyword">const</span>
	{
		<span class="hljs-keyword">return</span> Point(<span class="hljs-keyword">cast</span>(<span class="hljs-keyword">int</span>) x, <span class="hljs-keyword">cast</span>(<span class="hljs-keyword">int</span>) y);
	}

	v2 opBinary(<span class="hljs-built_in">string</span> op)(<span class="hljs-keyword">const</span> v2 rhs) <span class="hljs-keyword">const</span>
	{
		<span class="hljs-keyword">mixin</span>(<span class="hljs-string">`return v2(x`</span>, op, <span class="hljs-string">`rhs.x,y`</span>, op, <span class="hljs-string">`rhs.y);`</span>);
	}

	v2 opBinary(<span class="hljs-built_in">string</span> op)(<span class="hljs-keyword">const</span> <span class="hljs-built_in">float</span> rhs) <span class="hljs-keyword">const</span>
	{
		<span class="hljs-keyword">mixin</span>(<span class="hljs-string">`return v2(x`</span>, op, <span class="hljs-string">`rhs,y`</span>, op, <span class="hljs-string">`rhs);`</span>);
	}

	<span class="hljs-keyword">ref</span> <span class="hljs-keyword">auto</span> opIndex(size_t index)
	{
		<span class="hljs-keyword">return</span> arrayof[index];
	}
}
</div></code></pre>
<p>Acum funcția <code>samplePoints()</code> care evaluează funcția dată într-un interval dat, cu un număr de estimări dat.
Funcția returnează un tablou dinamic (am făcut aici leneș, deoarece am putea să prealochez tabloul, deoarece știm lungimea apriori).</p>
<pre class="hljs"><code><div>v2[] samplePoints(<span class="hljs-built_in">float</span> <span class="hljs-built_in">delegate</span>(<span class="hljs-built_in">float</span>) func, v2 rangeX, <span class="hljs-built_in">float</span> numSamples)
{
	v2[] result;
	<span class="hljs-built_in">float</span> step = (rangeX[<span class="hljs-number">1</span>] - rangeX[<span class="hljs-number">0</span>]) / numSamples;

	<span class="hljs-keyword">foreach</span> (i; <span class="hljs-number">0.</span>.numSamples)
	{
		<span class="hljs-built_in">float</span> x = i * step + rangeX[<span class="hljs-number">0</span>];
		result ~= v2(x, func(x)); 
	}

	result ~= v2(rangeX[<span class="hljs-number">1</span>], func(rangeX[<span class="hljs-number">1</span>]));

	<span class="hljs-keyword">return</span> result;
}
</div></code></pre>
<p>Și apelez funcția la startul programului, astfel:</p>
<pre class="hljs"><code><div>v2 rangeX = v2(-<span class="hljs-number">0.99</span>, <span class="hljs-number">0.99</span>);
<span class="hljs-keyword">int</span> numSamples = <span class="hljs-number">200</span>;
<span class="hljs-built_in">float</span> epsilon = <span class="hljs-number">0.0001f</span>;
<span class="hljs-keyword">const</span> samples = samplePoints(a =&gt; arctanh(a, epsilon), rangeX, numSamples); 
</div></code></pre>
<p>Având aceasta, este timpul să desenăm graficul.
În primul rând, desenăm liniile de coordonate centrate în mijlocul ecranului. (Originea nu ar fi necesar 0, depinde de funcție).</p>
<pre class="hljs"><code><div>painter.drawLine(Point(<span class="hljs-number">0</span>, height / <span class="hljs-number">2</span>), Point(width, height / <span class="hljs-number">2</span>));
painter.drawLine(Point(width / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>), Point(width / <span class="hljs-number">2</span>, height));
</div></code></pre>
<p><img src="images/lab1_axes.png" alt=""></p>
<p>Acum vom desena <em>pips</em> — indicatorii distanțate uniform ce indică x și y.
Codul este mai complicat.
De fapt este un joc cu coordonatele funcției și coordonatele pe fereastă, normalizarea și centrarea lor.
Îl voi plasa și aici, dar nu aștept că îl veți înțelege.
Numele variabilelor ar putea fi mai bune.</p>
<pre class="hljs"><code><div>Pen pen;
pen.width = <span class="hljs-number">1</span>;
pen.color = Color.blue;
pen.style = Pen.Style.Solid; 
painter.pen = pen;

<span class="hljs-keyword">auto</span> maximumY = samples.fold!((a, el) =&gt; max(a, el.y))(-<span class="hljs-built_in">float</span>.max);
<span class="hljs-keyword">auto</span> minimumY = samples.fold!((a, el) =&gt; min(a, el.y))(<span class="hljs-built_in">float</span>.max);
<span class="hljs-keyword">auto</span> leeway = <span class="hljs-number">0.1</span>;

<span class="hljs-keyword">auto</span> rangeY = v2(minimumY, maximumY);
<span class="hljs-keyword">auto</span> origin = v2(rangeY[<span class="hljs-number">1</span>] + rangeY[<span class="hljs-number">0</span>], rangeX[<span class="hljs-number">1</span>] + rangeX[<span class="hljs-number">0</span>]) / <span class="hljs-number">2</span>;
<span class="hljs-comment">// auto start = (v2(rangeX[0], rangeY[0]) - origin) * (1 + leeway) + origin;</span>
<span class="hljs-keyword">auto</span> end = (v2(rangeX[<span class="hljs-number">1</span>], rangeY[<span class="hljs-number">1</span>]) - origin.y) * (<span class="hljs-number">1</span> + leeway) + origin.y;

<span class="hljs-keyword">int</span> numberOfpips = <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span> pipHeight = <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span> numberOfPipsPlus1 = numberOfpips + <span class="hljs-number">1</span>;
v2 offsetScreen = v2(screenCenter.x / numberOfPipsPlus1, screenCenter.y / numberOfPipsPlus1);
v2 halfSpace = end - origin;
v2 individualOffset = halfSpace / numberOfPipsPlus1;

<span class="hljs-keyword">foreach</span> (i; -numberOfpips..numberOfpips + <span class="hljs-number">1</span>)
{
    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
    v2 p = origin + individualOffset * i;
    Point screenPoint = (offsetScreen * i).point;
    <span class="hljs-keyword">import</span> std.conv, std.format;
    {
      	<span class="hljs-comment">// x pips</span>
      	Point screenStart = Point(screenPoint.x, -pipHeight / <span class="hljs-number">2</span>) + screenCenter;
      	Point screenEnd = Point(screenPoint.x, pipHeight / <span class="hljs-number">2</span>) + screenCenter;
      	painter.drawLine(screenStart, screenEnd);
      	<span class="hljs-keyword">auto</span> str = <span class="hljs-string">"%2.2f"</span>.format(p.x);
      	painter.drawText(screenEnd - Point(painter.textSize(str).width / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>), str);
    }
    {
	    <span class="hljs-comment">// y pips</span>
	    Point screenStart = Point(-pipHeight / <span class="hljs-number">2</span>, -screenPoint.y) + screenCenter;
	    Point screenEnd = Point(pipHeight / <span class="hljs-number">2</span>, -screenPoint.y) + screenCenter;
	    painter.drawLine(screenStart, screenEnd);
	    <span class="hljs-keyword">auto</span> str = <span class="hljs-string">"%2.2f"</span>.format(p.y);
	    painter.drawText(screenEnd - Point(<span class="hljs-number">0</span>, painter.textSize(str).height / <span class="hljs-number">2</span>), str);
    }
}
</div></code></pre>
<p><img src="images/lab1_pips.png" alt=""></p>
<p>Și acum desenarea graficului.
Cum am menționat anterior, vom conecta punctele câte două cu linii.
Aici cel mai complicat moment este să calculăm coordonatele puctului pe fereastă având punctele în &quot;spațiul funcției&quot;.</p>
<p>Funcția <code>getPoint()</code> face această transformare. Ea ia un punct din &quot;spațiul funcției&quot;, îi inversează y-ul (<code>s * v2(1, -1)</code>), îl normalizează (<code>/ halfSpace</code>) pentru a primi offsetul de la 0 la 1 de la origine, și îl scalează la offsetul propriu de la centrul ferestrei (<code>* dimensions / 2</code>), pe urmă adaugă coordonatele centrului (<code>screenCenter +</code>).</p>
<pre class="hljs"><code><div>v2 dimensions() { <span class="hljs-keyword">return</span> v2(width, height); }
<span class="hljs-keyword">void</span> graph(<span class="hljs-keyword">const</span> v2[] samples, <span class="hljs-keyword">ref</span> ScreenPainter painter, v2 halfSpace) 
{
	<span class="hljs-keyword">auto</span> getPoint(v2 s) { <span class="hljs-keyword">return</span> screenCenter + (s * v2(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>) / halfSpace * dimensions / <span class="hljs-number">2</span>).point; }

	<span class="hljs-keyword">auto</span> p0 = getPoint(samples[<span class="hljs-number">0</span>]);
	<span class="hljs-keyword">foreach</span> (s1; samples[<span class="hljs-number">1.</span>.$])
	{
		<span class="hljs-keyword">auto</span> p1 = getPoint(s1);
		painter.drawLine(p0, p1);
		p0 = p1;
	}
}
</div></code></pre>
<p>Apelăm această funcție după ce am desenat axele:</p>
<pre class="hljs"><code><div>graph(samples, painter, halfSpace);
</div></code></pre>
<p><img src="images/lab1_graph.png" alt=""></p>
<h3 id="3-graficul-de-referin%C8%9B%C4%83">3. Graficul de referință</h3>
<p>Aici nimic nou, utilizăm deja descrisă funcția <code>samplePoints()</code> pentru a funcție din librărie, și folosim deja descrisă <code>graph()</code> pentru a desena graficul:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> referenceSamples = samplePoints(a =&gt; std.math.atanh(a), rangeX, numSamples);
<span class="hljs-comment">// ...</span>
pen.color = Color.red;
painter.pen = pen;
graph(referenceSamples, painter, halfSpace);
</div></code></pre>
<p><img src="images/lab1_reference_graph.png" alt=""></p>
<p>Funcția inițială a fost acoperită de funcția nouă, deci am aproximat-o corect.</p>
<h3 id="4-fi%C8%99ierul-cu-comparare">4. Fișierul cu comparare</h3>
<p>Trivial, scriem toate datele necesare într-un fișier csv:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">void</span> writePointsComparisonCsv(<span class="hljs-built_in">string</span> path, <span class="hljs-keyword">const</span> v2[] samples, <span class="hljs-keyword">const</span> v2[] referenceSamples, <span class="hljs-built_in">float</span> epsilon)
{
	<span class="hljs-keyword">auto</span> f = File(path, <span class="hljs-string">"w"</span>);
	f.writeln(<span class="hljs-string">"x,y,reference_y,delta,epsilon"</span>);
	<span class="hljs-keyword">foreach</span> (i, sample; samples)
	{
		f.writefln(<span class="hljs-string">"%f,%f,%f,%f,%f"</span>, sample.x, sample.y, referenceSamples[i].y, abs(sample.y - referenceSamples[i].y), epsilon);
	}
	f.close();
}
<span class="hljs-comment">// ...</span>
writePointsComparisonCsv(<span class="hljs-string">"atanh_comparison.csv"</span>, samples, referenceSamples, epsilon);
</div></code></pre>
<p>Aici vedem că diferența este mai mare decât $ \epsilon $, deoarece nu am condiția de oprire matematică corectă.
Cum $ sin(x) $ așa condiție simplă <code>while (abs(dx) &gt; epsilon)</code> va lucra, deoarece avem factoriale în numitori, însă aici avem o serie aritmetică în numitori.</p>
<pre class="hljs"><code><div>x,y,reference_y,delta,epsilon
-0.990000,-2.642694,-2.646653,0.003959,0.000100
-0.980100,-2.298060,-2.300092,0.002032,0.000100
-0.970200,-2.094270,-2.095691,0.001421,0.000100
...
</div></code></pre>
<p>Dacă schimb condiția la, de exemplu <code>while (abs(dx) &gt; epsilon * epsilon)</code>, avem unele aproximări mai bune:</p>
<pre class="hljs"><code><div>x,y,reference_y,delta,epsilon
-0.990000,-2.646650,-2.646653,0.000003,0.000100
-0.980100,-2.300093,-2.300092,0.000001,0.000100
-0.970200,-2.095690,-2.095691,0.000001,0.000100
...
</div></code></pre>
<h3 id="5-fi%C8%99ierul-cu-valorile">5. Fișierul cu valorile</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">void</span> writePointCsv(<span class="hljs-built_in">string</span> path, <span class="hljs-keyword">const</span> v2[] samples)
{
	<span class="hljs-keyword">auto</span> f = File(path, <span class="hljs-string">"w"</span>);
	f.writeln(<span class="hljs-string">"x,y"</span>);
	<span class="hljs-keyword">foreach</span> (sample; samples)
	{
		f.writefln(<span class="hljs-string">"%f,%f"</span>, sample.x, sample.y);
	}
	f.close();
}
<span class="hljs-comment">// ...</span>
writePointCsv(<span class="hljs-string">"atanh.csv"</span>, samples);
</div></code></pre>
<pre class="hljs"><code><div>x,y
-0.990000,-2.642694
-0.980100,-2.298060
-0.970200,-2.094270
-0.960300,-1.948759
...
</div></code></pre>
<h3 id="6-program-extern">6. Program extern</h3>
<p>Este de ajuns să cautăm pe Google graficul lui $ arctanh $ pentru a ne asigura că sunt de fapt egale.</p>
<p><img src="images/lab1_arctanh_google_graph.gif" alt=""></p>
<p>Nu văd prea mult sens să mai descarc un program care posibil nici nu acceptă formatul csv de valori, etc.</p>

</body>
</html>
